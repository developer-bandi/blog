---
title: "React-Hook-Form Deep Dive - 3. useForm(등록)"
date: "2025-01-19T21:20:18.164Z"
description: "React Hook Form의 가장 중요한 hook인 useForm의 register함수를 중심으로 등록과정을 살펴봅니다."
category: "기술아티클"
estimation: 15
thumbnail: "./thumbnail.png"
slug: "/react-hook-form-deep-dive-3"
---

이번 장에서는 useForm의 메서드중 가장 많이 사용되는 register 메서드를 살펴보겠습니다. register가 언제 실행되는지, 그리고 실행된 결과가 어떤 의미를 갖는지 살펴볼것입니다.

## register 함수 최초 실행
가장 먼저 살펴볼것은 register함수가 실행되고 값을 반환하기 이전까지의 로직입니다. 값을 반환하기 이전의 코드만 추출하여 분석해봅시다.

```typescript
// 1. _fields객체에서 name에 해당하는 field를 가져옵니다.
let field = get(_fields, name);

// 2. form의 disabled 여부를 판단합니다.
const disabledIsDefined =
  isBoolean(options.disabled) || isBoolean(props.disabled);

// 3. _fields에 field를 등록합니다.
set(_fields, name, {
  ...(field || {}),
  _f: {
    ...(field && field._f ? field._f : { ref: { name } }),
    name,
    mount: true,
    ...options,
  },
});

// 4. 현재 field를 mount 상태로 변경합니다.
_names.mount.add(name);

// 5. field 존재 유무에 따라 함수 실행
if (field) {
  _updateDisabledField({
    field,
    disabled: isBoolean(options.disabled) ? options.disabled : props.disabled,
    name,
    value: options.value,
  });
} else {
  updateValidAndValue(name, true, options.value);
}
```
첫번째 항목을 살펴보겠습니다. 먼저 `_fields`객체에서 등록하려는 필드의 이름을 이용해 필드를 가져옵니다. `_fields`에는 우리가 등록한 필드가 저장된다는 사실을 떠올리셨다면 "아직 등록하지도 않은 필드가 `_fields`에 있을수 없기 때문에 항상 `undefined`가 나올텐데 왜 조회하지?" 라는 생각을 하셨을것입니다. 하지만 불필요한 코드를 두었을리는 없기 때문에 이 코드가 존재한다는 것은 `register` 함수가 호출되는시점에 이미 name을 key로 하는 필드가 존재하는 상황이 있다는 것입니다. 이는 이후 코드를 추가적으로 살펴보면 알 수 있을것입니다. 지금은 register가 호출될때 필드가 존재할 수 있다 정도만 이해하고 넘어가시면 되겠습니다.

두번째 항목에서는 이 폼이 disabled상태인지 판단합니다. 이때 `options.disabled`가 `props.disabled`보다 우선순위가 높습니다. 이유는 options는 register에 개별적으로 적용하는것이고 props는 useForm에 적용하는 것이기에 options의 범위가 조금 더 좁기 때문입니다. 

세번째 항목에서는 _fields에 element를 등록 합니다. 여기서도 첫번째 라인을 보면, `...(field || {})`,와 같이 기존 정보에 추가정보를 넣고있습니다. 즉 _field에 값이 있는 경우가 존재한다는 의미입니다. 새롭게 추가되는 정보는 _f 프로퍼티에 추가되는데, ref, name, mount, options 값이 추가됩니다. ref의 경우 기존에 추가된 정보가 있는것이 아니라면 현재 ref 정보가 없으므로 유일하게 존재하는 name 만 넣어줍니다. 나머지 프로퍼티의 경우 추가적으로 설명할것이 없으므로 넘어가겠습니다.

네번째 항목에서는 현재 field를 mount 상태로 변경하기위해 `_names.mount` Set에 현재 field의 name을 추가해줍니다. 

마지막 항목은 field 존재 유무에 따라 다른 함수를 실행합니다. 여기서는 field가 undefined이므로 else문이 실행되어 `updateValidAndValue`함수를 실행하게됩니다. 해당 함수를 살펴보겠습니다.

```typescript
const updateValidAndValue = (
  name: InternalFieldName,
  shouldSkipSetValueAs: boolean,
  value?: unknown,
  ref?: Ref
) => {
  const field: Field = get(_fields, name);

  if (field) {
    // 1. 기본값을 설정합니다.
    const defaultValue = get(
      _formValues,
      name,
      isUndefined(value) ? get(_defaultValues, name) : value
    );

    // 2. 조건에 따라 set 또는 setFieldValue 함수를 실행합니다.
    isUndefined(defaultValue) ||
    (ref && (ref as HTMLInputElement).defaultChecked) ||
    shouldSkipSetValueAs
      ? set(
          _formValues,
          name,
          shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)
        )
      : setFieldValue(name, defaultValue);

    // 3. 현재 마운트 상태라면 valid 상태를 업데이트합니다.
    _state.mount && _updateValid();
  }
};
```
첫번째 항목은 기본값을 설정하는 것입니다. 여기서 기본값은 `_formValues`에서 꺼내오지만, 우리는 아직 `_formValues`에 값을 설정한적이 없으므로, 세번째 인자인 기본값이 그대로 반환될것을 예상해볼수 있습니다. 함수의 세번째 인자인 value는 option.value이므로 register를 실행할때 옵션으로 value를 넘기지 않았다면 전체 필드의 기본값을 가져오고, 그렇지 않다면 해당 값을 그대로 사용합니다.

두번째 항목은 조건에 따라 set 또는 setFieldValue 함수를 실행하는것입니다. set은 코드를 보면 알 수 있듯이 _formValues에 값을 설정하는것입니다. setFieldValue는 set의 기능에 더해 ref요소에 value를 넣어주는 역할을 가지고 있습니다. 이러한 맥락에서 볼때 조건식은 ref요소에 value를 넣어줄 필요가 없는 경우임을 알 수 있습니다. defaultValue가 undefined이면 굳이 설정할필요가 없고, ref에 defaultChecked가 활성화 되어있으면 이미 설정되어있으므로 필요없고, shouldSkipSetValueAs가 true인것은 set을 지시하는 강제 플래그 활성화 입니다. 따라서 이 항목은 defaultValue도 undefined이고 설사 값이 있더라도 shouldSkipSetValueAs가 true 이므로 _formValues에만 defaultValue를 설정하게됩니다. setFieldValue함수에 대해서는 추후 이 라인을 실행할때 보다 자세히 살펴보겠습니다.

마지막으로 현재 _state.mount가 true라면, _updateValid를 실행하게 됩니다. 다만 현재 _state.mount를 true로 변경한적이 없기에(초기에 수행한 mount관련 작업은 mount set에 ref를 추가한것입니다.) _updateValid는 실행되지 않습니다. 

## 객체 반환하기
반환문 이전 모든 라인을 살펴보았습니다. 이제 이 함수가 반환하는 객체를 살펴보겠습니다. 

```typescript
{
  // 1. disabled 프로퍼티를 설정합니다.
  ...(disabledIsDefined
    ? { disabled: options.disabled || props.disabled }
    : {}),
  // 2. progressive 속성에 따라 build-in validation을 내보내는 작업
  ...(_options.progressive
    ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue<number>(options.minLength) as number,
        maxLength: getRuleValue(options.maxLength) as number,
        pattern: getRuleValue(options.pattern) as string,
      }
    : {}),
  name,
  // 3. onChange,onBlur 콜백 추가
  onChange,
  onBlur: onChange,
  // 4. ref 콜백 추가
  ref: (ref: HTMLInputElement | null): void => {
    // 생략된 콜백함수 body
  },
};
```
첫번째 항목은 disabled 속성을 설정하는 로직입니다. 앞서 정의한 disabledIsDefined를 이용하는데, 값이 있을때만 disabled 속성을 추가합니다. 여기도 동일하게 option이 우선순위를 가지는것을 확인할 수 있습니다.  

두번째 항목은 progressive 속성의 값에 따라 build-in validation을 내보내는 로직입니다. 이는 우리가 register에 등록한 option중 build-in validation에 해당하는 속성을 그대로 반환하여 input 요소에 직접 등록할 수 있도록 해줍니다. 다만 7.53.0 버전에서 정식으로 지원하고 있는 기능은 아니고 실험적으로 제공중인 기능입니다.

세번째 항목은 onChange와 onBlur의 콜백함수를 추가하는 작업입니다. 두 프로퍼티 모두 같은 함수를 사용하며 onChange내에는 두 이벤트를 모두 받을수있도록 처리되어있습니다. 이는 추후 onChange 메서드를 사용할때 다시 살펴볼것입니다. 

마지막요소는 ref입니다. 일반적으로는 ref에 useRef나 createRef로 생성한 값을 넣게되는데, 사실 ref를 인자로 받는 콜백을 넘길수도 있습니다. useRef 혹은 createRef 대신 콜백을 사용하는 상황은 정확히 몇개의 요소가 등록될지 알 수 없을때입니다. useRef 혹은 createRef를 동적으로 실행할수 없으니, 대신 ref에 콜백함수에서 동적으로 ref를 조작할수 있도록 해준것입니다. useForm의 경우에도 몇개의 react element가 등록될지 알수 없기 때문에 콜백을 사용합니다. 이 콜백함수는 마운트시에 인자에 ref가 넘겨져서 실행되고, 콜백함수가 변경되면 변경되기 이전의 함수의 인자에 null이 담겨서 한번, 변경된 함수의 인자에 ref가 담겨서 한번 실행되며, 언마운트 되면 null이 담겨 실행됩니다. 

위 객체가 반환되면 register함수의 실행은 종료되어 콜스택은 제거되며, 이후 react의 마운트 시점에 ref에 담긴 콜백함수가 실행됩니다. 

> ref에 콜백함수를 넘기는것과 관련하여 더 자세한 내용은 https://react.dev/learn/manipulating-the-dom-with-refs 참고해보세요.

## ref 콜백함수 실행하기
앞서 설명드린것 처럼 ref의 콜백이 처음 실행되는 시점은 최초 렌더링, 즉 마운트 시점입니다. 그 이후로는 리렌더링때마다 두번씩 실행되고, 마지막으로 언마운트시 실행됩니다. 아래 콜백함수의 본문을 마운트/리렌더링/언마운트 시점에 따라 분석해보겠습니다.

```typescript
if (ref) {
  register(name, options);
  field = get(_fields, name);

  const fieldRef = isUndefined(ref.value)
    ? ref.querySelectorAll
      ? (ref.querySelectorAll("input,select,textarea")[0] as Ref) || ref
      : ref
    : ref;

  const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
  const refs = field._f.refs || [];

  if (
    radioOrCheckbox
      ? refs.find((option: Ref) => option === fieldRef)
      : fieldRef === field._f.ref
  ) {
    return;
  }

  set(_fields, name, {
    _f: {
      ...(radioOrCheckbox
        ? {
            refs: [
              ...refs.filter(live),
              fieldRef,
              ...(Array.isArray(get(_defaultValues, name)) ? [{}] : []),
            ],
            ref: { type: fieldRef.type, name },
          }
        : { ref: fieldRef }),
    },
  });

  updateValidAndValue(name, false, undefined, fieldRef);
} else {
  field = get(_fields, name, {});

  if (field._f) {
    field._f.mount = false;
  }

  (_options.shouldUnregister || options.shouldUnregister) &&
    !(isNameInFieldArray(_names.array, name) && _state.action) &&
    _names.unMount.add(name);
}
```

### 마운트
마운트 시점에는 ref에 null이 아니라 값이 제대로 들어오므로, if문이 실행됩니다. 이때 로직은 크게 register를 재실행하는 것과, 이후 ref를 설정하는 로직으로 나눌수 있겠습니다.

#### register 함수 재호출

콜백함수에서 가장 먼저 실행되는 함수는 다름아닌 register 함수입니다. 이로써 register 함수가 실행될때 field가 존재하는 상황은 바로 ref의 콜백함수에서 호출한 상황임을 알 수 있습니다.

```typescript
// 1. _fields객체에서 name에 해당하는 field를 가져옵니다.
let field = get(_fields, name);

// 2. form의 disabled 여부를 판단합니다.
const disabledIsDefined =
  isBoolean(options.disabled) || isBoolean(props.disabled);

// 3. _fields에 field를 등록합니다.
set(_fields, name, {
  ...(field || {}),
  _f: {
    ...(field && field._f ? field._f : { ref: { name } }),
    name,
    mount: true,
    ...options,
  },
});

// 4. 현재 field를 mount 상태로 변경합니다.
_names.mount.add(name);

// 5. field 존재 유무에 따라 업데이트합니다.
if (field) {
  _updateDisabledField({
    field,
    disabled: isBoolean(options.disabled) ? options.disabled : props.disabled,
    name,
    value: options.value,
  });
} else {
  updateValidAndValue(name, true, options.value);
}
```
첫번째 항목을 살펴보겠습니다. 현재 시점에는 처음 register 함수 실행시 등록해둔 field가 있기 때문에, field가 undefined가 아닌 field가 객체가 존재하는 상태가 됩니다.

두번째, 세번째, 네번째 항목의 경우 처음 register를 실행했을때와 차이가 없이 모두 동일한 값을 가지고 액션을 취하게 됩니다.

마지막 항목인 분기분은 조금 다릅니다. 여기서는 field가 undefined가 아니므로 if문이 실행됩니다. 해당 if 문에서는 _updateDisabledField함수가 실행됩니다. 해당 함수를 분석해보겠습니다.

```typescript
const _updateDisabledField: Control<TFieldValues>["_updateDisabledField"] = ({
  disabled,
  name,
  field,
  fields,
  value,
}) => {
  // 1. 함수를 실행하는 조건
  if ((isBoolean(disabled) && _state.mount) || !!disabled) {
    // 2. inputValue 결정 및 _formValue에 설정
    const inputValue = disabled
      ? undefined
      : isUndefined(value)
      ? getFieldValue(field ? field._f : get(fields, name)._f)
      : value;
    set(_formValues, name, inputValue);
    
    // 3.updateTouchAndDirty함수 실행
    updateTouchAndDirty(name, inputValue, false, false, true);
  }
}
```
첫번째 항목을 분석해보겠습니다. 조건은 _state.mount가 true이고 disabled에 값이 설정되어있거나, disabled가 true이면 아래 로직을 실행합니다. disabled가 false일때 _state.mount가 true로 되어있어야하는 이유는 아직 마운되지 않은 시점에 disabled가 false라는 것은 기본 상태로, 아직 변경할 필요가 없기 때문입니다. 여기서는 disabled 조건을 설정했다고 가정하고, 아래 로직을 살펴보겠습니다.

두번째 항목은 inputValue입니다. 크게 어려운부분은 없는데, disabled가 있으면 값을 설정하고, 그렇지 않으면 undefined로 변경해버립니다. 그리고 해당 값을 _formValue에 설정합니다.

세번째 항목은 updateTouchAndDirty를 실행하는것입니다. 함수 이름만 봐서는 짐작이 어려우니 함수 본문을 직접 보겠습니다. 

```typescript
  const updateTouchAndDirty = (
    name: InternalFieldName,
    fieldValue: unknown,
    isBlurEvent?: boolean,
    shouldDirty?: boolean,
    shouldRender?: boolean,
  ): Partial<
    Pick<FormState<TFieldValues>, 'dirtyFields' | 'isDirty' | 'touchedFields'>
  > => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output: Partial<FormState<TFieldValues>> & { name: string } = {
      name,
    };
    const disabledField = !!(
      get(_fields, name) &&
      get(_fields, name)._f &&
      get(_fields, name)._f.disabled
    );

    // 1. isDirty 업데이트
    if (!isBlurEvent || shouldDirty) {
      if (_proxyFormState.isDirty) {
        isPreviousDirty = _formState.isDirty;
        _formState.isDirty = output.isDirty = _getDirty();
        shouldUpdateField = isPreviousDirty !== output.isDirty;
      }

      const isCurrentFieldPristine =
        disabledField || deepEqual(get(_defaultValues, name), fieldValue);

      isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name));
      isCurrentFieldPristine || disabledField
        ? unset(_formState.dirtyFields, name)
        : set(_formState.dirtyFields, name, true);
      output.dirtyFields = _formState.dirtyFields;
      shouldUpdateField =
        shouldUpdateField ||
        (_proxyFormState.dirtyFields &&
          isPreviousDirty !== !isCurrentFieldPristine);
    }
    
    // 2. touchedFields 업데이트
    if (isBlurEvent) {
      const isPreviousFieldTouched = get(_formState.touchedFields, name);

      if (!isPreviousFieldTouched) {
        set(_formState.touchedFields, name, isBlurEvent);
        output.touchedFields = _formState.touchedFields;
        shouldUpdateField =
          shouldUpdateField ||
          (_proxyFormState.touchedFields &&
            isPreviousFieldTouched !== isBlurEvent);
      }
    }

    // 3. state 반영
    shouldUpdateField && shouldRender && _subjects.state.next(output);

    return shouldUpdateField ? output : {};
  };
```
첫번째 항목은 _formState의 isDirty와 dirtyFields를 업데이트 하는 로직입니다. 첫번째 조건을 보면 blur이벤트가 아니거나 shouldDirty 값이 true일때 실행됩니다. 그리고 두번째 조건문은 isDirty를 업데이트 하는 로직입니다. isDirty가 사용중인경우 _formState와 output에 isDirty를 업데이트 하고, 이전 값과의 변경여부에 따라 shouldUpdateField를 업데이트 합니다. 그리고는 dirtyFields를 업데이트 합니다. 현재 필드가 깨끗하거나 disabled상태라면 dirtyFields에서 필드를 제거하고, 그렇지 않다면 필드를 추가합니다. 그리고 output도 업데이트 해준뒤 이전값과의 변경에따라 shouldUpdateField를 업데이트합니다. 

두번째 항목은 _formState의 touchedFields를 업데이트 하는 로직입니다. touched는 error나 valid와 다르게, change나 blur이벤트를 통해 false와 true 양방향으로 이동할수 없고 false에서 true로 이동하는것만 가능합니다. 왜냐하면 한번 필드가 터치되면 이를 되돌릴수 없기 때문입니다. 이를 기반으로 조건을 분석해보면, 첫번째조건은 blur이벤트 여부인데, touched가 blur이벤트, 즉 포커스를 잃을때 발생하기 때문입니다. 두번째 조건은 isPreviousFieldTouched가 false일때 아래로직이 실행됩니다. 이는 true에서 false로 갈수 없기 때문입니다. 이때 _formState와 output객체에 값을 설정한뒤 _proxyFormState객체의 프로퍼티가 true이고, isPreviousFieldTouched와isBlurEvent가 다를때 필드 업데이트 로직을 true로 변경합니다. 여기서는 blur이벤트가 아니므로 전체 조건문이 실행되지는 않습니다.

세번째 항목은 앞선 두 항목에서 변경하였던 shouldUpdateField와 인자로 들어온 shouldRender가 모두 true일때 state를 업데이트하게됩니다.

즉 정리하자면 disabled변경되면 dirty에도 영향이 있기 때문에 해당함수를 실행함을 알 수 있습니다.

#### ref 설정하기
여기부터는 register 함수를 실행한 이후 ref 콜백함수의 실행흐름을 살펴보겠습니다. 이 실행의 목적을 한줄로 요약하면, field에 ref를 설정하기 라고 할수 있겠습니다.

```typescript
field = get(_fields, name);

// 1. ref 결정하기
const fieldRef = isUndefined(ref.value)
  ? ref.querySelectorAll
    ? (ref.querySelectorAll("input,select,textarea")[0] as Ref) || ref
    : ref
  : ref;

const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
const refs = field._f.refs || [];

// 2. 예외처리
if (
  radioOrCheckbox
    ? refs.find((option: Ref) => option === fieldRef)
    : fieldRef === field._f.ref
) {
  return;
}

// 3. ref 설정하기
set(_fields, name, {
  _f: {
    ...field._f,
    ...(radioOrCheckbox
      ? {
          refs: [
            ...refs.filter(live),
            fieldRef,
            ...(Array.isArray(get(_defaultValues, name)) ? [{}] : []),
          ],
          ref: { type: fieldRef.type, name },
        }
      : { ref: fieldRef }),
  },
});

// 4. updateValidAndValue 실행
updateValidAndValue(name, false, undefined, fieldRef);
```
첫번째 항목에서는 fieldRef를 결정합니다. 그냥 인자로 들어온 ref를 fieldRef로 하면 될것 같지만, 그렇지 않은 예외 경우(input을 div로 감싸는등)을 위한 로직입니다. 만약 ref.value가 빈문자열이라면 문제 없지만, undefined라면 input ref가 아니므로 하위 자식 요소에서 input,select,textarea 요소를 하나 찾아 넣습니다. 그럼에도 없으면 빈값이 설정됩니다.

두번째 항목은 예외처리 조건입니다. radioOrCheckbox인지 여부에 따라 다르지만 fieldRef가 현재 설정되어있는지를 확인하고 만약 이미 설정되어있다면 아래 로직을 실행할 필요가 없기때문에 조기반환해버립니다.radioOrCheckbox의 경우 refs에서 fieldRef와 일치하는요소를 찾는데, 이유는 아래에서 확인할 수 있습니다. 

세번째 항목은 _field의 ref를 설정하는것입니다. 여기에는 두가지 케이스가 있습니다. 일반적인 라디오나 체크박스가 아닌 input은 ref에 fieldRef를 그대로 담습니다. 그런데, 라디오나 체크박스에는 값을 그대로 담지 않습니다. 왜냐하면 이들은 동일한 요소를 여러개 사용하기 때문입니다. 따라서 ref에는 타입과 이름만 담고, 모든 ref를 refs에 넣어 관리합니다. 이를 통해 앞서 왜 체크박스나 라디오는 ref를 refs에서 찾았는지 알 수 있습니다.

마지막으로 updateValidAndValue를 실행합니다. 앞서 register 함수의 본문에서 실행될때와 달리 두번째 인자인 shouldSkipSetValueAs가 false임을 생각하면서 분석해봅시다.

```typescript
const updateValidAndValue = (
  name: InternalFieldName,
  shouldSkipSetValueAs: boolean,
  value?: unknown,
  ref?: Ref
) => {
  const field: Field = get(_fields, name);

  if (field) {
    // 1. 기본값을 설정합니다.
    const defaultValue = get(
      _formValues,
      name,
      isUndefined(value) ? get(_defaultValues, name) : value
    );

    // 2. 조건에 따라 set 또는 setFieldValue 함수를 실행합니다.
    isUndefined(defaultValue) ||
    (ref && (ref as HTMLInputElement).defaultChecked) ||
    shouldSkipSetValueAs
      ? set(
          _formValues,
          name,
          shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)
        )
      : setFieldValue(name, defaultValue);

    // 3. 현재 마운트 상태라면 valid 상태를 업데이트합니다.
    _state.mount && _updateValid();
  }
};

```
첫번째 항목에서는 기본값을 설정합니다. 앞선 과정에서와 달리, _formValue가 설정되어있으므로 기본값을 사용하지 않고 그대로 꺼내옵니다.

두번째 항목은 defaultValue가 undefined가 아니고 값이 없다면, setFieldValue함수를 실행하게 됩니다. 해당 함수는 앞서 언급한것 처럼 _formValue와 ref에 값을 설정하는데, 이를 라디오, 체크박스, 셀렉트 요소등 타입에 따라 다르게 적용하는 로직입니다. 관심이 있으시다면 아래 함수를 복사해두었으니 주석을 참고하여 상황별로 어떻게 타입별로 다르게 처리하는지 확인해보시면 좋겠습니다.

```typescript
  const setFieldValue = (
    name: InternalFieldName,
    value: SetFieldValue<TFieldValues>,
    options: SetValueConfig = {},
  ) => {
    const field: Field = get(_fields, name);
    let fieldValue: unknown = value;

    if (field) {
      const fieldReference = field._f;

      if (fieldReference) {
        // disabled 상태가 아니라면 _formValues에 현재 element의 값을 설정합니다.
        !fieldReference.disabled &&
          set(_formValues, name, getFieldValueAs(value, fieldReference));

        // HTMLElement이고, value가 null 또는 undefined이면 빈값을 설정합니다.
        fieldValue =
          isHTMLElement(fieldReference.ref) && isNullOrUndefined(value)
            ? ''
            : value;

        // multiple이 설정된 select인 경우 select의 옵션을 조회하여 value와 일치하는 option을 select 상태로 만들어줍니다.
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach(
            (optionRef) =>
              (optionRef.selected = (
                fieldValue as InternalFieldName[]
              ).includes(optionRef.value)),
          );

          // refs가 설정되어있는(radio 또는 checkbox)경우
        } else if (fieldReference.refs) {
          // checkbox인 경우 value에 따라 checked를 업데이트해줍니다.
          // 만약 value가 array인경우 이에 해당하는 값을 checked상태로 바꾸고, 그렇지 않은 값 두가지를 비교합니다.
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1
              ? fieldReference.refs.forEach(
                  (checkboxRef) =>
                    (!checkboxRef.defaultChecked || !checkboxRef.disabled) &&
                    (checkboxRef.checked = Array.isArray(fieldValue)
                      ? !!(fieldValue as []).find(
                          (data: string) => data === checkboxRef.value,
                        )
                      : fieldValue === checkboxRef.value),
                )
              : fieldReference.refs[0] &&
                (fieldReference.refs[0].checked = !!fieldValue);
            // type="radio"인 input의 경우 refs를 순회하면서 value와 fieldValue가 같은경우 checked상태로 만듭니다.
          } else {
            fieldReference.refs.forEach(
              (radioRef: HTMLInputElement) =>
                (radioRef.checked = radioRef.value === fieldValue),
            );
          }
          // 파일 input을 value로 직접 세팅할수 없으므로 초기화
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = '';
          // 일반적인 경우 단순히 ref에 값을 설정해줍니다.
        } else {
          fieldReference.ref.value = fieldValue;

          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: { ..._formValues },
            });
          }
        }
      }
    }
  };
```

마지막으로 현재 _state.mount가 true라면, _updateValid를 실행하게 됩니다. 다만 현재 _state.mount를 true로 변경한적이 없기에(초기에 수행한 mount관련 작업은 mount set에 ref를 추가한것입니다.) _updateValid는 실행되지 않습니다. 일반적인 상황에서 register함수 실행시 _state.mount가 true가 되지 않습니다. 이는 이후 변경을 살펴볼때 알 수 있을것입니다.

### 리렌더링시

리렌더링시에는 ref에 null이 들어온채로 한번, ref에 값이 들어온채로 한번, 총 두번 실행됩니다. 순서대로 살펴보겠습니다.

#### ref에 null이 넘어오는 경우
이경우 else문이 실행됩니다. 

```typescript
// 1. field 재설정
field = get(_fields, name, {});

// 2. field 마운트 상태 변경
if (field._f) {
  field._f.mount = false;
}

// 3. field 마운트 상태 변경
// shouldUnregister옵션이 켜져있고, arrayField이면서 활성화된경우  _names.unMount에 추가해둠(추후 _removeUnmounted가 실행되어 등록해제됨)
(_options.shouldUnregister || options.shouldUnregister) &&
  _names.unMount.add(name);
```
첫번째 항목은 field를 다시 가져옵니다. 왜냐하면 폼이 리렌더링되면서 field가 변경되었을수 있기 때문입니다.

두번째 항목에서는 field의 마운트 상태를 false로 변경합니다. 이때 리렌더링이 발생하는것이라 아직 마운트 상태인데 false로 변경하면 안될것 같아보입니다. 하지만 초기 register실행시 field._f.mount를 true로 변경하는 로직이 있기 때문에 문제 없습니다. 

세번째 항목에서는 조건에 따라 unMount에 이름을 추가합니다. 조건은 shouldUnregister의 옵션이 켜져있는지 여부입니다. 이 옵션은 언마운트시 값을 유지할지를 결정하는데 unMount에 값을 넣으면 사라진다는것을 알 수 있습니다. 추가적으로 이값은 useForm에서 제거합니다. 그런데 여기도 마찬가지로 리렌더링시에는 아직 제거할 생각이 없는데 unMount에 넣는것을 보면 문제가 있을것 같아보이는데, 이는 코드를 보면 문제가 없음을 알 수 있습니다. 

```typescript
// useForm
React.useEffect(() => {
  control._removeUnmounted();
});
  
// createFormControl
const _removeUnmounted = () => {
  // _names.unMount 내에 있는 모든 name 순회
  for (const name of _names.unMount) {
    const field: Field = get(_fields, name);

    // refs가 있는 경우 refs의 모든 요소에 대해 그렇지 않은 경우 ref요소에 대해 live 상태이면 unregister 함수를 실행합니다.
    field &&
      (field._f.refs
        ? field._f.refs.every((ref) => !live(ref))
        : !live(field._f.ref)) &&
      unregister(name as FieldPath<TFieldValues>);
  }

  // _names.unMount에 담긴 필드를 모두 unmount처리하였으므로 _names.unMount를 초기화합니다.
  _names.unMount = new Set();
};
```
코드를 보면 unMount을 순회하면서 unregister함수를 적용할때 live여부를 판단하고 있기때문에, 실제로 언마운트 된것이 아니라면 unMount안에 있더라도 코드가 실행되지 않습니다.

#### ref가 제대로 넘어오는 경우
가장 먼저 register를 재실행합니다.

```typescript
// 1. _fields객체에서 name에 해당하는 field를 가져옵니다.
let field = get(_fields, name);

// 2. form의 disabled 여부를 판단합니다.
const disabledIsDefined =
  isBoolean(options.disabled) || isBoolean(props.disabled);

// 3. _fields에 field를 등록합니다.
set(_fields, name, {
  ...(field || {}),
  _f: {
    ...(field && field._f ? field._f : { ref: { name } }),
    name,
    mount: true,
    ...options,
  },
});

// 4. 현재 field를 mount 상태로 변경합니다.
_names.mount.add(name);

// 5. field 존재 유무에 따라 업데이트합니다.
if (field) {
  _updateDisabledField({
    field,
    disabled: isBoolean(options.disabled) ? options.disabled : props.disabled,
    name,
    value: options.value,
  });
} else {
  updateValidAndValue(name, true, options.value);
}
```
이 로직은 벌써 세번째입니다. 세번씩이나 보았기 때문에 우리가 주목해야할 부분은 바로 disabled입니다. field가 있을때는 항상 _updateDisabledField를 실행합니다. 즉, 리렌더링시 register함수를 실행하는 이유는 변경된 disabled 값을 반영해주기 위함임을 알 수 있습니다.

그리고 나서는 이제 나머지 아래 로직을 실행하게 됩니다.

```typescript
field = get(_fields, name);

const fieldRef = isUndefined(ref.value)
  ? ref.querySelectorAll
    ? (ref.querySelectorAll("input,select,textarea")[0] as Ref) || ref
    : ref
  : ref;

const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
const refs = field._f.refs || [];

if (
  radioOrCheckbox
    ? refs.find((option: Ref) => option === fieldRef)
    : fieldRef === field._f.ref
) {
  return;
}
```
그 이후에는 ref가 등록되어있으므로 조기 반환되어 ref 등록 로직은 수행하지 않습니다.
 
### 언마운트시
언마운트시에는 ref요소에 null이 담겨서 else문이 실행됩니다. 이때의 else문은 리렌더링시 파악한 내용과 동일하므로 추가적으로 살펴보지 않겠습니다.

## 마치며
이번 아티클에서는 `register`를 분석하면서 필드의 등록과정을 살펴보았습니다. 많은 내용을 분석했지만 중요한것은 register함수의 실행결과 `_fields`에 필드 정보가 추가되고, `_formValue`에 해당 필드의 기본값이 담긴다는것입니다. 

다음 장에서는 값을 변경하는 과정에 대해서 살펴보겠습니다.